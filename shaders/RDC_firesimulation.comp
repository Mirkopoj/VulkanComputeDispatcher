#version 450

layout(binding = 0) buffer In {
	float Incendiandose[];
	float Suseptibles[];
} In;

layout(binding = 1) buffer Out {
	float Incendiandose[];
	float Suseptibles[];
} Out;

//Mapas de Altitud Vegetacion WindAngle WindInt
layout(binding = 2) buffer Mapas {
	float Altitud[];
	float Vegetacion[];
	float WindAngle[];
	float WindInt[];
} Mapas;

/**
* Para evitar calcular los bordes se lanzan 2 menos threads por eje y se usa un offset de 1.
*/
vec2 get_position(){
	return gl_GlobalInvocationID.xy + vec2(1, 1);
}

uint get_index(vec2 pos, uint width) {
	return pos.x + pos.y * width;
}

void main() {
	uint width = gl_WorkGroupSize.x * gl_NumWorkGroups.x; 

	vec4 outc;
	float beta = 1.0f;
	float gamma = 0.2f;
	float Difu = 1.0f;
	float Cwind = 0.1f; //constante a ajustar que acompaña al vector viento
	float Cslope = 0.2f;

	vec2 centro_pos = get_position();
	uint centro = get_index(centro_pos, width);

	uint arriba = get_index(centro_pos - vec2(0, 1), width);
	uint abajo = get_index(centro_pos + vec2(0, 1), width);
	uint izquierda = get_index(centro_pos - vec2(1, 0), width);
	uint derecha = get_index(centro_pos + vec2(1, 0), width);

	float Sus_centro = In.Suseptibles[centro];

	float Inc_arriba = In.Incendiandose[arriba];
	float Inc_izquierda = In.Incendiandose[izquierda];
	float Inc_centro = In.Incendiandose[centro];
	float Inc_derecha = In.Incendiandose[derecha];
	float Inc_abajo = In.Incendiandose[abajo];

	float alti_arriba = Mapas.Altitud[arriba];
	float alti_izquierda = Mapas.Altitud[izquierda];
	float alti_derecha = Mapas.Altitud[derecha];
	float alti_abajo = Mapas.Altitud[abajo];
	float alti_centro = Mapas.Altitud[centro];

	float vege_centro = Mapas.Vegetacion[centro];

	float winda_centro = Mapas.WindAngle[centro];
	float windi_centro = Mapas.WindInt[centro];

/* En cada celda tendremos un tipo mayoritario de combustible que determinara la velocidad
	de la transmision del calor beta que cambiara de celda en celda pero que en cada celda es constante.
	 Por esto beta(r)S es el n�mero efectivo de sitios que pueden quemarse. Si tengo un beta bajo, aunque tenga
	 muchos S se va a quemar poco y lo mismo si tengo un beta alto y pocos sitios S para quemar.*/


	if(vege_centro>=0.0f && vege_centro<2.5f) // vege == 0,1 o 2 no queman
		{
			Difu = 0.0f;//0.0f;
			beta = 0.0f;
		}
		else if(vege_centro>2.5f && vege_centro<3.5f) // vege == 3, Bosque A
		{
			Difu = 0.4f;//0.2f;
			beta = 0.4f;
		}
		else if(vege_centro>3.5f && vege_centro<4.5f) // vege == 4  Bosque B
		{
			Difu = 0.5f;//0.3f;
			beta = 0.5f;
		}
		else if(vege_centro>4.5f && vege_centro<5.5f) // vege == 5 Bosque Insertado el que mas quema
		{
			Difu = 0.6f;//0.5f;
			beta = 0.6f;
		}
		else if(vege_centro>5.5f && vege_centro<6.5f) // vege == 6 pastizal
		{
			Difu = 0.9f;//0.9f;
			beta = 0.9f;
		}
		else if(vege_centro>6.5f && vege_centro<7.5f) // vege == 7 arbustal
		{
			Difu = 0.7f;//0.7f;
			beta = 0.7f;
		}

	//Difu = 0.7f;//0.7f;
	//beta = 0.7f;

	float Inc_clamp_value=2.0f;

	// si no esta en ninguno de los 4 bordes
	//Termino de difusion del calor es como si los sitios incendiandose "difundieran" a sus vecinos. La corriente de transmision del calor es proporcional al gradiente de T y suponemos que la Temperatura aumenta con el numero de sitios incendiandose.
	//if (x>0 && x<l - 1 && y>0 && y<l - 1) {
	float laplacianInc =
						clamp(Inc_arriba - Inc_centro, -Inc_clamp_value, Inc_clamp_value) 
					 + clamp(Inc_abajo - Inc_centro, -Inc_clamp_value, Inc_clamp_value) 
					 + clamp(Inc_derecha - Inc_centro, -Inc_clamp_value, Inc_clamp_value) 
					 + clamp(Inc_izquierda - Inc_centro, -Inc_clamp_value, Inc_clamp_value)
					 * 0.25f;
	//}

	//Termino convectivo (viento, pendiente)
	//VIENTO
	float vecx = +0.5f;
	//sin(d_wind[centro]); //aca habria que descomponer el viento en x y en y REVISAR d_wind es el angulo de la direccion del viento
	float vecy = -0.5f;
	//cos(d_wind[centro]);

	//windi_centro=0.001f;

	vecx=-windi_centro*sin(winda_centro*3.1415f/180.0f);
	vecy=-windi_centro*cos(winda_centro*3.1415f/180.0f);

	vec3 waux=vec3(0,0,0);
	vec3 wauxi=vec3(0,0,0);

	if(vecx<0) {wauxi.x=1.0f;}
	if(vecx>0) {waux.x=1.0f;}
	if(vecy>0) {wauxi.y=1.0f;}
	if(vecy<0) {waux.y=1.0f;}

	float viento_clamp_value=50.0f;


	float convective_wind = 	
					- clamp(vecx, -viento_clamp_value, viento_clamp_value)  * (wauxi.x) * clamp(Inc_derecha - Inc_centro, -Inc_clamp_value, Inc_clamp_value) 
					+ clamp(-vecx, -viento_clamp_value, viento_clamp_value) * (waux.x)  * clamp(Inc_centro - Inc_izquierda, -Inc_clamp_value, Inc_clamp_value) 
					+ clamp(vecy, -viento_clamp_value, viento_clamp_value)  * (wauxi.y) * clamp(Inc_abajo - Inc_centro, -Inc_clamp_value, Inc_clamp_value) 
					+ clamp(vecy, -viento_clamp_value, viento_clamp_value)  * (waux.y)  * clamp(Inc_centro - Inc_arriba, -Inc_clamp_value, Inc_clamp_value);


	//Gradiente de ALTURAS por gradiente de Sitios Incendiandose

	//float convective_slope = (alti_derecha - alti_izquierda)*0.5*(Inc_derecha - Inc_izquierda) +(alti_arriba - alti_abajo)*0.5*(Inc_arriba - Inc_abajo);

	waux=vec3(0,0,0);
	wauxi=vec3(0,0,0);

	if((alti_centro-alti_derecha)>0) {wauxi.x=1.0f;}
	if((alti_centro-alti_izquierda)>0) {waux.x=1.0f;}
	if((alti_centro-alti_abajo)>0) {wauxi.y=1.0f;}
	if((alti_centro-alti_arriba)>0) {waux.y=1.0f;}

	float pendiente_clamp_value=50.0f; //OJO, ES PORCENTAJE DE PENDIENTE, NO GRADOS.


	float convective_slope = 	
							- clamp((alti_derecha - alti_centro)/0.3f, -pendiente_clamp_value, pendiente_clamp_value)   * (wauxi.x) * clamp(Inc_derecha - Inc_centro, -Inc_clamp_value, Inc_clamp_value)
							- clamp((alti_centro - alti_izquierda)/0.3f, -pendiente_clamp_value, pendiente_clamp_value) * (waux.x)  * clamp(Inc_centro - Inc_izquierda, -Inc_clamp_value, Inc_clamp_value)
							- clamp((alti_abajo - alti_centro)/0.3f, -pendiente_clamp_value, pendiente_clamp_value)     * (wauxi.y) * clamp(Inc_abajo - Inc_centro, -Inc_clamp_value, Inc_clamp_value)
							- clamp((alti_centro - alti_arriba)/0.3f, -pendiente_clamp_value, pendiente_clamp_value)    * (waux.y)  * clamp(Inc_centro - Inc_arriba, -Inc_clamp_value, Inc_clamp_value);

	//*dSusdt = -beta*Sus_centro*Inc_centro;

//	outc.r=Difu*laplacianInc + beta*Sus_centro*Inc_centro - gamma * Inc_centro;// + Cwind*convective_viento + Cslope*convective_slope;

	//beta*Sus_centro*Inc_centro Es bastante suave y gradual. valores menores que 1
	//Difu * laplacianInc 	Tiene con valores altos las zonas donde se producen las divergencias. valores andan por 1.0f
	//gamma * Inc_centro 	Valores menores que 1 y suaves en todo el mapa
	//Cslope*convective_slope Valores altos en zonas de divergencias, valores max entre 1 y 2

	//outc.r = beta*Sus_centro*Inc_centro + Difu * laplacianInc- gamma * Inc_centro + 0.3f*Cslope*convective_slope + Cwind*convective_wind; // + Cslope*convective_slope;
	outc.r = beta*Sus_centro*Inc_centro + Difu * laplacianInc- gamma * Inc_centro + 0.3f*Cslope*convective_slope + Cwind*convective_wind; // + Cslope*convective_slope;
	//outc.g=-outc.r;
	outc.g= -beta*Sus_centro*Inc_centro;

	if(outc.r<0.0001f && outc.r>0.0f)outc.r=0.0f;//PARA EVITAR PROPAGACION DE INCENDIANDOSE SIN RESTAR SUCEPTIBLES
	if(outc.g<0.0001f && outc.g>0.0f)outc.g=0.0f;//PROBANDO

	if((vege_centro>=0.0f && vege_centro<2.5f)||Sus_centro<=0.0001f) // vege == 0,1 o 2 no queman
	{
		outc.r=0.0f;//PONERLO FUERA DEL SHADER
		outc.g=0.0f;
	}

	if(isinf(outc.r)||isnan(outc.r)||outc.r>100.0f||outc.r<-100.0f){outc.r=0.0f;}
	if(isinf(outc.g)||isnan(outc.g)||outc.g>0.0f||outc.g<-100.0){outc.g=0.0f;}

	Out.Suseptibles[centro] = outc.r;
	Out.Incendiandose[centro] = outc.g;
}
